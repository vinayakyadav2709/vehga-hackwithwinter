import os
import sys
import argparse
import time
import threading
import traci
import utils
import junction
import fdrl_server
import models
from metrics import MetricsTracker
from decision_logger import decision_logger


SUMO_PORT = 9999
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

# Configuration files generated by setup_network.py
CONFIG_FILES = {
    'train': 'fdrl.sumocfg',
    'test': 'fdrl.sumocfg',
    'actuated': 'actuated.sumocfg',
    'fixed_time': 'fixed.sumocfg'
}

AGGREGATION_INTERVAL = 500
LOCAL_WEIGHT_RETENTION = 0.5  # Balanced local/global learning
SAVE_PATH = "global_model.pth"


def parse_args():
    parser = argparse.ArgumentParser(description="FDRL Traffic Management System")
    parser.add_argument(
        "--mode",
        type=str,
        choices=["train", "test", "actuated", "fixed_time"],
        default="train",
        help="'train' from scratch/pretrained or 'test' with frozen weights",
    )
    parser.add_argument(
        "--load", type=str, default=None, help="Path to pretrained model (optional)"
    )
    parser.add_argument(
        "--episodes", type=int, default=1, help="Number of simulation episodes"
    )
    parser.add_argument(
        "--no-gui", action="store_true", help="Run SUMO in headless mode (no GUI)"
    )
    return parser.parse_args()


def run_simulation(args, server, agents, episode_num, metrics_tracker):
    """Main simulation loop with FL aggregation and metrics tracking."""
    step = 0
    aggregation_count = 0
    train_mode = args.mode == "train"

    print(f"\n>> Episode {episode_num + 1}/{args.episodes} (Mode: {args.mode})...")
    
    # Print Table Header
    header = f"{'Step':<8} | {'Total Wait':<12} | {'Avg Wait':<10} | {'Avg Speed':<10} | {'Queue':<8} | {'Active EMG':<10}"
    if train_mode:
        header += f" | {'Epsilon':<8}"
    print(header)
    print("-" * len(header))

    while traci.simulation.getMinExpectedNumber() > 0:
        traci.simulationStep()
        current_time = traci.simulation.getTime()

        # Skip first few steps to let simulation stabilize
        if step < 10:
            step += 1
            continue

        # Local Agent Updates
        for agent in agents.values():
            agent.step(current_time, train=train_mode)

        # Federated Aggregation (Only in training mode)
        if train_mode and step > 0 and step % AGGREGATION_INTERVAL == 0:
            print() # Blank line
            print(f"[Step {step}] >> Aggregation Round {aggregation_count + 1}...", flush=True)

            client_weights = [
                agent.get_weights() for agent in agents.values() if agent.get_weights()
            ]
            new_global_weights = server.aggregate(client_weights)

            for agent in agents.values():
                agent.update_weights(new_global_weights, alpha=LOCAL_WEIGHT_RETENTION)

            server.save_model(SAVE_PATH)
            aggregation_count += 1

        # Logging
        if step % 100 == 0:
            total_wait = 0
            total_queue = 0
            total_wait = 0
            total_speed = 0
            total_vol = 0
            active_agents = 0

            for agent in agents.values():
                # raw features: [queue, wait, speed, vol, occ, emg_count, emg_wait, has_emg]
                # We need raw values, so we pass None as normalizer
                raw_stats = utils.get_aggregated_features(agent.all_lanes, normalizer=None)
                total_queue += raw_stats[0]
                total_wait += raw_stats[1]
                total_speed += raw_stats[2]
                total_vol += raw_stats[3]
                active_agents += 1
            
            avg_system_speed = total_speed / max(1, active_agents)
            avg_wait_per_vehicle = total_wait / max(1, total_vol)

            # Get current emergency vehicle stats
            vehicle_stats = metrics_tracker.vehicle_metrics.get_current_stats()
            
            # Update metrics tracker with vehicle tracking AND simulation metrics
            metrics_tracker.step(step, {
                'total_wait': total_wait,
                'avg_wait': avg_wait_per_vehicle,
                'avg_speed': avg_system_speed,
                'total_queue': total_queue,
            })

            epsilon = (
                agents[list(agents.keys())[0]].brain.epsilon if train_mode and hasattr(agents[list(agents.keys())[0]], 'brain') and agents[list(agents.keys())[0]].brain else 0.0
            )
            
            # Log Row with emergency vehicle count
            row = f"\r{step:<8} | {total_wait:<12.1f} | {avg_wait_per_vehicle:<10.1f} | {avg_system_speed:<10.2f} | {total_queue:<8.0f} | {vehicle_stats['active_emergency']:<10}"
            if train_mode:
                row += f" | {epsilon:<8.3f}"
            
            print(row, flush=True)

        step += 1

    # Print comprehensive episode summary using metrics tracker
    metrics_tracker.print_episode_summary(episode_num)


def main():
    args = parse_args()
    
    # Select config file based on mode
    current_config = CONFIG_FILES.get(args.mode, 'fdrl.sumocfg')

    # Validate config exists
    if not os.path.exists(os.path.join(PROJECT_DIR, current_config)):
        print(f"Error: {current_config} not found. Run: uv run python setup_complex_environment.py")
        sys.exit(1)

    # Start SUMO
    use_gui = not args.no_gui
    proc = utils.start_sumo_docker(PROJECT_DIR, current_config, port=SUMO_PORT, gui=use_gui)

    try:
        traci.init(port=SUMO_PORT, host="localhost")

        # Initialize Server
        baseline_model = models.TrafficSignalScorer()
        server = fdrl_server.FDRLServer(baseline_model)

        # Load pretrained model if specified
        if args.load and os.path.exists(args.load):
            print(f">> Loading model from {args.load}...")
            server.load_model(args.load)
        elif args.mode == "test":
            print("Error: Test mode requires --load <model_path>")
            sys.exit(1)

        # Initialize Agents
        tls_ids = traci.trafficlight.getIDList() # gets all junctions/controllers
        print(f">> Discovered {len(tls_ids)} Junctions: {tls_ids}")

        global_weights = server.get_global_weights()
        agents = {}

        for tid in tls_ids:
            if args.mode == "actuated":
                agent = junction.ActuatedAgent(tid)
            elif args.mode == "fixed_time":
                agent = junction.FixedTimeAgent(tid)
            else:
                agent = junction.JunctionAgent(tid)
                if args.load:
                    agent.brain.set_weights(global_weights)
                if args.mode == "test":
                    agent.brain.epsilon = 0.0  # Disable exploration
            agents[tid] = agent

        # Initialize metrics tracker
        metrics_tracker = MetricsTracker()
        
        # Start API server in background
        try:
            import uvicorn
            from api_server import app, set_metrics_tracker, update_simulation_state, update_junctions
            
            # Share metrics tracker with API
            set_metrics_tracker(metrics_tracker)
            
            # Start API server in daemon thread
            def run_api_server():
                uvicorn.run(app, host="0.0.0.0", port=8000, log_level="warning")
            
            api_thread = threading.Thread(target=run_api_server, daemon=True)
            api_thread.start()
            print(">> API server started at http://localhost:8000")
            print(">> API docs at http://localhost:8000/docs")
            time.sleep(1)  # Give API time to start
        except Exception as e:
            print(f"Warning: Could not start API server: {e}")
            print("Continuing without API...")
            update_simulation_state = lambda x: None  # No-op
            update_junctions = lambda x: None  # No-op

        # Run Episodes
        for ep in range(args.episodes):
            run_simulation(args, server, agents, ep, metrics_tracker)

            # Reset for next episode
            if ep < args.episodes - 1:
                traci.load(["-c", f"/sumo-projs/{current_config}"])
                for agent in agents.values():
                    agent.reset()
                metrics_tracker.reset_episode()
                decision_logger.reset_episode()

    except traci.exceptions.FatalTraCIError as e:
        print(f"TraCI Error: {e}")
    except KeyboardInterrupt:
        print("\n>> Interrupted by user")
    finally:
        traci.close()
        proc.kill()
        print(">> Shutdown complete")


if __name__ == "__main__":
    main()
